<?php

/**
 * @file
 * Adds autocomplete="off" to form text inputs
 * (this is only the *browser* autocomplete which remembmers previous values,
 * it doesn't affect ajax autocomplete, which is what the term usually refers to)
 * 
 * @todo hook field create/edit to make autocomplete off optional
 * @todo make sure this doesn't operate on admin forms.
 * 
 * @author sean
 */

define('NOTOCOMPLETE_DISABLED', 0);
define('NOTOCOMPLETE_ENABLED', 1);
define('NOTOCOMPLETE_FLAG_NAME', 'noto');
 
/**
 * Implements hook_form_FORM_ID_alter() for the node type form
 * 
 * this will add the notocomplet flag to the node type page. 
 * approach borrowed from the auto_nodetitle module.
 */
function notocomplete_form_node_type_form_alter(&$form, &$form_state) 
{
    $element_name = NOTOCOMPLETE_FLAG_NAME;
    $type_name = $form['#node_type']->type;
    
    // get the set value, defaulting to enabled
    // the values are being automatically saved in the variable [element_name]_[type_name] (ie; noto_blog)
    // where this is documented I can't find, but I pieced it together from the auto_nodetitle module.
    $current_val = variable_get( $element_name.'_'.$type_name, NOTOCOMPLETE_ENABLED );
    
    // create the fieldset
    $form['notocomplete'] = array(
        '#type' => 'fieldset',
        '#title' => t('Suppress field history'),
        '#collapsible' => true,
        '#collapsed' => true,
        '#group' => 'additional_settings'
    );
    
    // add the flag toggle to the fieldset
    $form['notocomplete'][$element_name] = array(
        '#type' => 'radios',
        '#default_value' => $current_val,
        '#options' => array(
            NOTOCOMPLETE_ENABLED => t('Set "autocomplete=off" attribute on text inputs'),
            NOTOCOMPLETE_DISABLED => t('Do not set autocomplete (make no change)')
        )
    );
}

/**
 * implements hook_node_type_insert
 */
function notocomplete_node_type_insert($info)
{
    variable_set('notocomplete_' .$info->type, variable_get('notocomplete_'.$info->type));
}
 
/**
 * implements hook_form_alter
 * 
 * this does the actual operation of modifying the form settings, where appropriate
 */
function notocomplete_form_alter(&$form, &$form_state, $form_id) 
{
    // sanity - notify user of unknown error
    if( !$form || empty($form) ) {
        drupal_set_message('Notocomplete: Form not recognised', 'error');
    }
    
    // find out what content type this is and whether notocomplete is wanted for it.
    // (see comments in hook_form_FORM_ID_alter implementation)
    $element_name = NOTOCOMPLETE_FLAG_NAME;
    $type_name = $form_state['node']->type;
    $noto_setting = variable_get($element_name.'_'.$type_name, NOTOCOMPLETE_ENABLED);
    
    if( $noto_setting===NOTOCOMPLETE_ENABLED ) {
        // now go over each of the form fields looking for a plain text type
        $form = arrayScanAndTransform($form, '#type', 'textfield', 'setAutocomplete');
    }
}

/**
 * scan an array for sub-arrays having a specific key with a specific value and perform some operation on them
 *
 * ie; scan for any sub-arrays where 'X' => Y then call a function that sets it to Z.
 * not using array_walk_recursive because it needs to operate on the whole array, rather than the item
 * warning: recursive!
 * 
 * @todo log something helpful on error
 * 
 * @param array $array scan for nested arrays in here
 * @param string $field scan for this key
 * @param mixed $value scan for this value (strict)
 * @param string $operation the function to run on matching sub-arrays
 * @return array|bool the modified array, or false on error
 */
function arrayScanAndTransform($array, $field, $value, $operation)
{
    // sanity
    if (!is_array($array)) {
        return false;
    }
    if (!function_exists($operation)) {
        return false;
    }
    
    // iterate over array
    // (must do by ref, otherwise only a copy of sub-arrays will be transformed)
    foreach( $array as $key=>&$val ) {
        
        // check for sub-arrays, do recursion
        if (is_array($val)) {
            $val = arrayScanAndTransform($val, $field, $value, $operation);
        }
        
        // check for matches. if found, operate on the array
        if ($key==$field && $val===$value) {
            $array = $operation($array);
        }
    }
    
    return $array;
}

/**
 * insert the autocomplete=off key into an array (oversetting if it exists)
 * 
 * @todo log something helpful on error
 * 
 * @see http://www.midwesternmac.com/blogs/jeff-geerling/disabling-autocomplete-form
 *      https://api.drupal.org/api/drupal/developer!topics!forms_api_reference.html/7#attributes
 * 
 * @param array $array
 * @return array|bool the modified array, or false on error
 */
function setAutocomplete(&$array)
{
    // sanity
    if (!is_array($array)) {
        return false;
    }
    
    // weird edge case: #attributes exists, but it's not an array
    if (array_key_exists('#attributes', $array) && !is_array($array['#attributes'])) {
        return FALSE;
    }
    
    // create if not exists
    if (!array_key_exists('#attributes', $array)) {
        $array['#attributes'] = array();
    }
    
    // now set the autocomplete field
    $array['#attributes']['autocomplete'] = 'off';
    
    return $array;
}
